id: oauth-state-bypass
info:
  name: OAuth State Parameter Bypass Detection
  author: geeknik
  severity: high
  description: |
    Detects OAuth implementations vulnerable to CSRF attacks through missing,
    predictable, or reusable state parameters in OAuth authorization flows.
  reference:
    - https://portswigger.net/web-security/oauth
    - https://datatracker.ietf.org/doc/html/rfc6749#section-10.12
  classification:
    cwe-id: CWE-352
  tags: oauth,csrf,authentication,bypass
  metadata:
    max-request: 5

variables:
  redirect_uri: "https://example.com/callback"
  client_id: "test_client_{{randstr}}"

requests:
  - method: GET
    path:
      - "{{BaseURL}}/oauth/authorize?response_type=code&client_id={{client_id}}&redirect_uri={{redirect_uri}}"
      - "{{BaseURL}}/oauth/authorize?response_type=code&client_id={{client_id}}&redirect_uri={{redirect_uri}}&state="
      - "{{BaseURL}}/oauth/authorize?response_type=code&client_id={{client_id}}&redirect_uri={{redirect_uri}}&state=predictable123"
      - "{{BaseURL}}/auth/oauth/authorize?response_type=code&client_id={{client_id}}&redirect_uri={{redirect_uri}}"
      - "{{BaseURL}}/oauth2/authorize?response_type=code&client_id={{client_id}}&redirect_uri={{redirect_uri}}"

    redirects: true
    max-redirects: 3

    matchers-condition: and
    matchers:
      - type: regex
        part: header
        regex:
          - 'Location:.*[?&]code='
      - type: dsl
        dsl:
          - "status_code == 302"
          - "!contains(tolower(location), 'state=') || contains(tolower(location), 'state=predictable123') || contains(location, 'state=&') || ends_with(location, 'state=')"
        condition: and

    extractors:
      - type: regex
        part: header
        name: oauth_flow
        regex:
          - 'Location:\s*([^\s]+)'

      - type: regex
        part: header
        regex:
          - '[?&]state=([^&]+)'
          - '[?&]code=([^&]+)'
